#!/usr/bin/python

import sys

from gi.repository import GObject
from gi.repository import Gtk

from Fallen.connections import Connections
from Fallen.player import Player
from Fallen import library


class Fallen:

    """
    Main Fallen application class
    """

    def __init__(self):

        # load the ui
        self.builder = Gtk.Builder()
        self.builder.add_from_file('Fallen/ui/main.ui')

        # set the window up
        window = self.builder.get_object('main-window')
        window.show_all()
        window.connect('destroy', self._handle_window_destroy)

        # player controls
        self.play = self.builder.get_object('play')
        self.play.connect('activate', self._handle_play)
        self.next = self.builder.get_object('next')
        self.next.connect('activate', lambda action: self.player.next());
        self.prev = self.builder.get_object('previous')
        self.prev.connect('activate', lambda action: self.player.prev());

        # track title label and timeline controls
        self.tracklabel = self.builder.get_object('track-name')
        self.playtime = self.builder.get_object('playtime')

        # playlist
        self.playlist = self.builder.get_object('playlist')

        # our cool classes to handle xmms
        self.player = Player()
        self.connections = Connections()
        self.connections.bring_up()

        # handle player events from xmms
        self.player.connect('status-change', self._handle_status_change)
        self.player.connect('track-change', self._handle_track_change)
        self.player.connect('playlist-change', self._handle_playlist_change)
        self.player.connect('playtime', self._handle_playtime)

        # use gobject mainloop
        self.mainloop = GObject.MainLoop()

    # -------------------------------------------------------------------------

    def _handle_window_destroy(self, window):
        self.mainloop.quit()

    def _handle_play(self, action):
        self.player.play() if action.get_active() else self.player.pause()

    # -------------------------------------------------------------------------

    def _handle_status_change(self, player, status):
        self.play.handler_block_by_func(self._handle_play)
        self.play.set_active(status == 1) # if playing
        self.play.handler_unblock_by_func(self._handle_play)
        self.tracklabel.set_sensitive(status != 0) # if not stopped
        if status == 0:
            self.tracklabel.set_text("Not playing")
            self.playtime.set_value(0)

    def _handle_playtime(self, player, time):
        self.playtime.set_value(int(time))

    def _handle_track_change(self, player, track):
        if track.info:
            self._handle_current_track_metadata(track)
        if self.player.current:
            self.player.current.disconnect_by_func(
                self._handle_current_track_metadata)
        track.connect('updated', self._handle_current_track_metadata)

    def _handle_current_track_metadata(self, track):
        label = '<b>%(title)s</b> by %(artist)s' % track.info
        self.tracklabel.set_markup(label.replace('&', '&amp;').encode('utf-8'))
        self.playtime.set_upper(int(track.info['duration']))

    def _handle_playlist_change(self, player, playlist):
        playlist.connect('entries-list', self._handle_playlist_entries_list)

    def _handle_playlist_entries_list(self, playlist):
        self.playlist.clear()
        for index, track in enumerate(playlist.entries):
            row = self.playlist.append([None, None, None, None, None, None])
            self.playlist.set_value(row, 0, index + 1)
            if track.info:
                self._handle_playlist_track_metadata(track, row)
            track.connect('updated', self._handle_playlist_track_metadata, row)

    def _handle_playlist_track_metadata(self, track, row):
        for index, key in enumerate(('title', 'artist', 'date', 'genre',
                                     'publisher')):
            self.playlist.set_value(row, index + 1,
                                    track.info[key].encode('utf-8'))

def main():
	fallen = Fallen()
	fallen.mainloop.run()

if __name__ == "__main__":
    main()

